// Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

// The Cangjie API is in Beta. For details on its capabilities and limitations, please refer to the README file.

package cjpm.config

import std.env.*
import std.fs.*
import std.collection.*
import std.convert.*
import stdx.serialization.serialization.*
import cjpm.toml.*
import cjpm.toml.Decoder as DecoderToml

public let REPO_CONFIG_FILE_NAME = "cangjie-repo.toml"
public let REPO_CACHE_NAME = "cache"
public let REPO_HOME_NAME = "home"

public class RepositoryInfo <: Serializable<RepositoryInfo> {
    public RepositoryInfo(
        public var path!: String = "",
        public var registry!: String = "",
        public var token!: String = ""
    ) {}

    public func serialize(): DataModel {
        let result = DataModelStruct()
        result.add(field<String>("path", this.path))
        result.add(field<String>("registry", this.registry))
        result.add(field<String>("token", this.token))
        return result
    }

    public static func deserialize(dm: DataModel): RepositoryInfo {
        var dms = match (dm) {
            case data: DataModelStruct => data
            case _ => throw Exception("this data is not DataModelStruct")
        }
        var result = RepositoryInfo()
        result.path = String.deserialize((dms.get("path") as DataModelString) ?? DataModelString(""))
        result.registry = String.deserialize((dms.get("registry") as DataModelString) ?? DataModelString(""))
        result.token = String.deserialize((dms.get("token") as DataModelString) ?? DataModelString(""))
        return result
    }
}

public class SettingsConfig <: Serializable<SettingsConfig> {
    public var repository: HashMap<String, RepositoryInfo> = HashMap<String, RepositoryInfo>()
    public var isValid: Bool = true

    public init() {
        this.repository.add(REPO_CACHE_NAME, RepositoryInfo())
        this.repository[REPO_CACHE_NAME].path = Path(DEFAULT_CONFIG_LOCATION).join(".cjpm").toString()
        this.repository.add(REPO_HOME_NAME, RepositoryInfo())
    }

    public func serialize(): DataModel {
        let result = DataModelStruct()
        result.add(field<HashMap<String, RepositoryInfo>>("repository", repository))
        return result
    }

    public static func deserialize(dm: DataModel): SettingsConfig {
        let dms = match (dm) {
            case data: DataModelStruct => data
            case _ => throw Exception("this data is not DataModelStruct")
        }
        var result = SettingsConfig()
        result.repository = HashMap<String, RepositoryInfo>.deserialize((dms.get("repository") as DataModelStruct) ?? DataModelStruct())

        if (!result.repository.contains(REPO_CACHE_NAME)) {
            result.repository.add(REPO_CACHE_NAME, RepositoryInfo())
            result.repository[REPO_CACHE_NAME].path = Path(DEFAULT_CONFIG_LOCATION).join(".cjpm").toString()
        }

        if (!result.repository.contains(REPO_HOME_NAME)) {
            result.repository.add(REPO_HOME_NAME, RepositoryInfo())
        }

        return result
    }
}

public func readConfigToml(file: Path): SettingsConfig {
    var res = SettingsConfig()
    try {
        let fileInfo = File(file, Read)
        let de = DecoderToml(fileInfo)
        let to = de.decode()
        res = SettingsConfig.deserialize(DataModel.fromToml(to))
        fileInfo.close()
    } catch (e: Exception) {
        eprintln(e.message)
        eprintln("Error: load file '${file}' failed.")
        res.isValid = false
        return res
    }

    if (res.repository.contains(REPO_CACHE_NAME) && !res.repository[REPO_CACHE_NAME].path.isEmpty()) {
        // Replace env vars and convert the path to an absolute path when path is relative path
        res.repository[REPO_CACHE_NAME].path = getPath(file.parent.toString(), replaceEnvVars(res.repository[REPO_CACHE_NAME].path))

    }

    if (res.repository.contains(REPO_CACHE_NAME) && res.repository[REPO_CACHE_NAME].path.isEmpty()) {
        // when path of [repository.cache] is empty, set $HOME/.cjpm or %USERPROFILE%/.cjpm as repository cache path
        res.repository[REPO_CACHE_NAME].path = Path(DEFAULT_CONFIG_LOCATION).join(".cjpm").toString()
    }

    return res
}

public func loadConfigInfo(): SettingsConfig {
    // Read the configuration file based on priority.
    if (fileExists(Path(DIR_CURRENT).join(REPO_CONFIG_FILE_NAME))) {
        return readConfigToml(Path(DIR_CURRENT).join(REPO_CONFIG_FILE_NAME))
    }

    if (fileExists(Path(DEFAULT_CONFIG_LOCATION).join(".cjpm").join(REPO_CONFIG_FILE_NAME))) {
        return readConfigToml(Path(DEFAULT_CONFIG_LOCATION).join(".cjpm").join(REPO_CONFIG_FILE_NAME))
    }

    var res = SettingsConfig()
    let cj_home: String = getVariable("CANGJIE_HOME") ?? return res
    if (fileExists(Path(cj_home).join("tools").join("config").join(REPO_CONFIG_FILE_NAME))) {
        res = readConfigToml(Path(cj_home).join("tools").join("config").join(REPO_CONFIG_FILE_NAME))
        let globalCjpmConfig = getVariable("CJPM_CONFIG") ?? return res
        println("Warning: the functionality of 'CJPM_CONFIG' will be deprecated, " +
            "please unset 'CJPM_CONFIG' and use cangjie-repo.toml to set the repository cache path")
        res.repository[REPO_CACHE_NAME].path = globalCjpmConfig
        return res
    }

    let globalCjpmConfig = getVariable("CJPM_CONFIG") ?? return res
    println("Warning: the functionality of 'CJPM_CONFIG' will be deprecated, " +
            "please unset 'CJPM_CONFIG' and use cangjie-repo.toml to set the repository cache path")
    res.repository[REPO_CACHE_NAME].path = globalCjpmConfig

    return res
}

func versionCompare(v1: String, v2: String): Bool {
    let vArr1: Array<String> = v1.split(".")
    let vArr2: Array<String> = v2.split(".")
    let vArrList1: ArrayList<Int64> = ArrayList<Int64>()
    let vArrList2: ArrayList<Int64> = ArrayList<Int64>()
    for (index in 0..3) {
        vArrList1.add(Int64.parse(vArr1[index]))
        vArrList2.add(Int64.parse(vArr2[index]))
    }
    if (vArrList2[0] > vArrList1[0] || (vArrList2[0] == vArrList1[0] && vArrList2[1] > vArrList1[1]) ||
        (vArrList2[0] == vArrList1[0] && vArrList2[1] == vArrList1[1] && vArrList2[2] > vArrList1[2])) {
        return true
    }
    return false
}

public func verifyDependencyField(dep: DepInfo, name: String, path: String): Bool {
    let isPathDep = dep.path.isSome()
    let isGitDep = dep.git.isSome()
    let isRepoDep = dep.version.isSome()

    if (!isPathDep && !isGitDep && !isRepoDep) {
        eprintln("Error: one of 'git' or 'path' or 'version' fields must exist " +
            "in dependency ${name} in ${Path(path).join(CONFIG_FILE_NAME).toString()}")
        return false
    }
    if ((isPathDep && isGitDep) || (isPathDep && isRepoDep) || (isGitDep && isRepoDep)) {
        eprintln("Error: only one of 'git' or 'path' or 'version' fields can exist " +
            "in dependency ${name} in ${Path(path).join(CONFIG_FILE_NAME).toString()}")
        return false
    }

    if (let Some(version) <- dep.version) {
        return centralVersionCheck(name, version, Path(path).join(CONFIG_FILE_NAME).toString())
    }

    return true
}
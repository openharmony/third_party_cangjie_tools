// Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

// The Cangjie API is in Beta. For details on its capabilities and limitations, please refer to the README file.

package cjpm.config

import std.regex.*
import std.fs.*

import cjpm.util.Result

// Regexp root package name.
let EXAMPLE_ROOT_PACKAGE_NAME: String = "cjDemo"
let EXAMPLE_ORG_NAME: String = "cjOrg"
let EXAMPLE_NAME_WITH_ORG: String = "cjOrg::cjDemo"
let EXAMPLE_ENV_NAME: String = "CJ_ENV_NAME"
// Basic string for version.
let FORMAT_OF_VERSION: String = "(([1-9][0-9]+)|[0-9])\\.(([1-9][0-9]+)|[0-9])\\.(([1-9][0-9]+)|[0-9])"
// Regexp version.
public let REGEXP_VERSION: String = "^${FORMAT_OF_VERSION}$"
let EXAMPLE_MODULE_VERSION: String = "1.0.0"
// Regexp repo-dependency require.
let REGEXP_REQUIRE_UNIT: String = "((${FORMAT_OF_VERSION})|((\\(|([\\(\\[]\\s*${FORMAT_OF_VERSION}))\\s*,\\s*(\\)|(${FORMAT_OF_VERSION}\\s*[\\)\\]]))))"
let REGEXP_DEP_REQUIRE: String = "^(\\s*${REGEXP_REQUIRE_UNIT}\\s*(,\\s*${REGEXP_REQUIRE_UNIT}\\s*)*)$"
// Regexp version.
let REGEXP_NAME_VERSION: String = "^(_*[a-zA-Z][_a-zA-Z0-9]*::)?(_*[a-zA-Z][_a-zA-Z0-9]*)-(([1-9][0-9]+)|[0-9])\\.(([1-9][0-9]+)|[0-9])\\.(([1-9][0-9]+)|[0-9])$"
public let EXAMPLE_NAME_VERSION: String = "cjModDemo-1.0.0"
let EXAMPLE_CJC_VERSION: String = "1.0.0"
// regexp c library name.
let REGEXP_C_LIB_NAME: String = "^[A-Za-z0-9\\._\\-#%\\+,=@\\[\\]\\^\\{\\}~]+$"
// Regexp condition value.
let REGEXP_CONDITON_VALUE: String = "^_*[a-zA-Z][_a-zA-Z0-9]*$"
let EXAMPLE_CONDITON_VALUE: String = "cfg_1"

// Regexp command injection.
@When[os == "Linux" || os == "macOS"]
let REGEXP_COMMAND_INJECTION = "[|;&$><`!\n\\\\]+"
@When[os == "Windows"]
let REGEXP_COMMAND_INJECTION = "[|;&$><`!\n]+"

// Check root package name in cjpm.toml.
public func nameCheck(text: String, path: String): Bool {
    if (text.size == 0) {
        eprintln("Error: the 'name' field in ${path} can't be empty")
        return false
    }
    let matched = Regex(REGEXP_CONDITON_VALUE)
    match (matched.find(text)) {
        case Some(_) => return true
        case None => eprintln("Error: the 'name' field '${text}' in ${path} is wrong, " +
            "the example is '${EXAMPLE_ROOT_PACKAGE_NAME}'")
    }
    return false
}

// Check root package organization in cjpm.toml.
public func organizationCheck(text: String, path: String): Bool {
    if (text.size == 0) {
        return true
    }
    let matched = Regex(REGEXP_CONDITON_VALUE)
    match (matched.find(text)) {
        case Some(_) => return true
        case None => eprintln("Error: the 'organization' field '${text}' in ${path} is wrong, " +
            "the example is '${EXAMPLE_ORG_NAME}'")
    }
    return false
}

// Analyse the package name, split org and name
public func analyzingPackageName(pkgName: String): (String, String) {
    if (pkgName.contains("::")) {
        let tomlNameArr= pkgName.split("::", 2)
        return (tomlNameArr[0], tomlNameArr[tomlNameArr.size - 1])
    }
    return ("", pkgName)
}

public func dependenciesNameCheck(text: String, path: String): Bool {
    let (org, name) = analyzingPackageName(text)
    if (name.size == 0) {
        eprintln("Error: the name of dependency in ${path} can't be empty")
        return false
    }

    let matched = Regex(REGEXP_CONDITON_VALUE)
    if ((org.isEmpty() || matched.find(org).isSome()) && matched.find(name).isSome()) {
        return true
    }

    eprintln("Error: the name of dependency '${text}' in ${path} is wrong, " +
        "the example is '${EXAMPLE_ROOT_PACKAGE_NAME}' or '${EXAMPLE_NAME_WITH_ORG}'")
    return false
}

// Check initial root package name.
public func nameCheck(text: String): Bool {
    if (text.size == 0) {
        eprintln("Error: the 'name' field can't be empty")
        return false
    }
    var matched = Regex(REGEXP_CONDITON_VALUE)
    match (matched.find(text)) {
        case Some(_) => return true
        case None => eprintln("Error: the 'name' field '${text}' is wrong, " +
            "the example is '${EXAMPLE_ROOT_PACKAGE_NAME}'")
    }
    return false
}

func cLibNameCheck(text: String, path: String): Bool {
    if (text.size == 0) {
        eprintln("Error: the c-library name can't be empty which is listed in 'ffi.c' field at ${path}")
        return false
    }
    let matched = Regex(REGEXP_C_LIB_NAME)
    match (matched.find(text)) {
        case Some(_) => return true
        case None => eprintln("Error: the c-library name '${text}' is wrong " +
            "which is listed in 'ffi.c' field at ${path}")
    }
    return false
}

// Check version in cjpm.toml.
func versionCheck(text: String, path: String): Bool {
    if (text.isEmpty()) {
        eprintln("Error: the 'version' field in ${path} can't be empty")
        return false
    }
    let matched = Regex(REGEXP_VERSION)
    match (matched.find(text)) {
        case Some(_) => return true
        case None => eprintln("Error: the 'version' field '${text}' in ${path} is wrong, " +
            "the example is '${EXAMPLE_MODULE_VERSION}'")
    }
    return false
}

// Check name:version args
public func nameVersionCheck(text: String): Bool {
    let matched = Regex(REGEXP_NAME_VERSION)
    match (matched.find(text)) {
        case Some(_) => return true
        case None => return false
    }
}

// Check central dependencies version in cjpm.toml.
func centralVersionCheck(name: String, text: String, path: String): Bool {
    if (name.isEmpty()) {
        eprintln("Error: name of dependency from central repository in ${path} can't be empty")
        return false
    }
    let matched = Regex(REGEXP_DEP_REQUIRE)
    match (matched.find(text)) {
        case Some(_) => return true
        case None => eprintln("Error: version '${text}' for central repository dependency '${name}' in ${path} " +
            "is wrong, the example is '1.2.3', '[1.2.3, 1.4.5)' or '(, 1.0.0), [2.0.0, )'")
    }
    return false
}

// Check cjc_version in cjpm.toml.
func cjcVersionCheck(text: String, path: String): Bool {
    if (text.isEmpty()) {
        eprintln("Error: the '${FILE_VERSION}' field in ${path} can't be empty")
        return false
    }
    let matched = Regex(REGEXP_VERSION)
    match (matched.find(text)) {
        case Some(_) => return true
        case None => eprintln("Error: the '${FILE_VERSION}' field '${text}' in ${path} is wrong, " +
            "the example is '${EXAMPLE_CJC_VERSION}'")
    }
    return false
}

// Check output_type in cjpm.toml.
func outputTypeCheck(text: String, path: String): Bool {
    if (!OutputType.fromString(text).isValid) {
        eprintln("Error: the 'output-type' field in ${path} is wrong, optional value are '${Static}/${Dynamic}/${Exe}'.")
        return false
    }
    return true
}

// Check the 'lto' field in cjpm.toml.
@When[os == "Linux"]
public func ltoValueCheck(text: String, path: String): Bool {
    if (text.isEmpty()) {
        return true
    }

    if (!LTO_TYPE_LIST.contains(text)) {
        let options: String = String.join(LTO_TYPE_LIST, delimiter: "/")
        eprintln("Error: the 'lto' field in ${path} is wrong, optional value are '${options}'")
        return false
    }

    return true
}

@When[os != "Linux"]
public func ltoValueCheck(_: String, _: String): Bool {
    return true
}

public func safeCheck(text: String, path: String): Bool {
    safeCheckResult(text, path: path)
        .inspectErr { err => eprintln("Error: ${err}") }
        .isOk
}

public func safeCheckResult(text: String, path!: String = ""): Result<String, String> {
    let hasPath: Bool = !path.isEmpty()
    if (Regex(REGEXP_COMMAND_INJECTION).matches(text)) {
        var errorString: String = "the '${text}' contains illegal characters"
        if (hasPath) {
            errorString += " in ${path}"
        }
        return Err(errorString)
    }
    return Ok(text)
}

public func sourcePathCheck(path: Path): Bool {
    !Regex(REGEXP_COMMAND_INJECTION).matches(path.toString())
}

public func customizedOptionCheck(option: String, path: String): Bool {
    let hasPath: Bool = !path.isEmpty()
    if (option.size <= 1) {
        var errorString: String = "Error: the length of customized key must be greater than 1"
        if (hasPath) {
            errorString += " in ${path}"
        }
        eprintln(errorString)
        return false
    }
    var matched = Regex(REGEXP_CONDITON_VALUE)
    match (matched.find(option)) {
        case Some(_) => return true
        case None =>
            var errorString: String = "Error: the customized key '${option}'"
            if (hasPath) {
                errorString += " in ${path}"
            }
            errorString += " is wrong, the example is '${EXAMPLE_CONDITON_VALUE}'"
            eprintln(errorString)
    }
    return false
}

// Check dependencies 'path' field in cjpm.toml.
func depPathCheck(text: String, errLoc: String, modulePath: String, moduleName: String): Bool {
    if (text.isEmpty()) {
        eprintln("Error: the path can't be empty which is listed in ${errLoc}")
        return false
    }
    let depPath: String = getPath(modulePath, text)
    if (!directoryExists(depPath)) {
        eprintln("Error: the path '${text}' of module '${moduleName}' does not exist which is listed in ${errLoc}")
        return false
    }
    return true
}

public func srcDirCheck(text: String, path: String, configPath: String): Bool {
    if (!safeCheck(text, configPath)) {
        return false
    }
    let srcDirPath = getPath(path, text)
    if (!directoryExists(srcDirPath)) {
        eprintln("Error: path of src directory '${text}' in ${configPath} does not exist")
        return false
    }
    let curDirPath = getCanonicalPath(path)
    if (!srcDirPath.startsWith(curDirPath)) {
        eprintln("Error: src file directory ${text} must be contained in module directory. " +
            "Please check field 'src-dir' in ${configPath}")
        return false
    }
    return true
}

public func envNameCheck(envName: String, cmd: String, configFilePath: String): Bool {
    var matched = Regex(REGEXP_CONDITON_VALUE)
    match (matched.find(envName)) {
        case Some(_) => return true
        case None => eprintln("Error: environment name '${envName}' in profile '${cmd}' in ${configFilePath} " +
            "is wrong, the example is '${EXAMPLE_ENV_NAME}'")
    }
    return false
}

public func fixCompileOption(compileOption: String, configFilePath: String): String {
    var res = compileOption
    res = fixTestOption(res, configFilePath)
    return res
}

func fixTestOption(compileOption: String, configFilePath: String): String {
    var flag = true
    var res = compileOption
    if (res == "--test") {
        res = ""
        flag = false
    }
    if (res.contains(" --test ")) {
        res = res.replace(" --test ", " ")
        flag = false
    }
    if (res.startsWith("--test ")) {
        res = res.removePrefix("--test ")
        flag = false
    }
    if (res.endsWith(" --test")) {
        res = res.removeSuffix(" --test")
        flag = false
    }

    if (!flag) {
        eprintln("Warning: '--test' in compile option of '${configFilePath}' will be ignored, " +
            "test configuration will be automatically added by 'cjpm test'")
    }

    return res
}

// Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

// The Cangjie API is in Beta. For details on its capabilities and limitations, please refer to the README file.

package cjpm.implement

import std.collection.*
import std.fs.*
import cjpm.config.*

// Command clean implement.
public func doClean(rootPath: String, cmdDir: String, isDebug: Bool): Bool {
    let tomlInfo: TomlInfo = loadModuleFile(rootPath) ?? return false
    let (flag, errInfo) = tomlInfo.isCompatible()
    if (!flag) {
        let tomlDir = Path(rootPath).join(CONFIG_FILE_NAME).toString()
        eprintln("Error: ${errInfo} at ${tomlDir}")
        return false
    }

    let (dirFlag, configFileDir) = getConfigFileDir(rootPath, tomlInfo)
    if (!dirFlag) {
        return false
    }

    var targetDir = getOriginTargetDirectory(TARGET, rootPath, cmdDir, configFileDir, false) ?? return false

    if (checkParentDir(getCanonicalPath(targetDir), getCanonicalPath(rootPath))) {
        eprintln("Error: cannot clean target directory which contains current directory, " +
            "please check related configuration")
        return false
    }

    var cleanDir: String = targetDir
    if (isDebug) {
        cleanDir = Path(cleanDir).join(DEBUG).toString()
    }
    if (!deleteDirectory(cleanDir)) {
        return false
    }
    let configScriptFileDir = getConfigScriptFileDir(rootPath, tomlInfo) ?? return false
    let scriptDir = getScriptDirectory(BUILD_SCRIPT_DIR, rootPath, configScriptFileDir, false) ?? return false

    if (checkParentDir(getCanonicalPath(scriptDir), getCanonicalPath(rootPath))) {
        eprintln("Error: cannot clean script directory which contains current directory, " +
            "please check related configuration")
        return false
    }

    var cleanScriptDir: String = scriptDir
    if (isDebug) {
        cleanScriptDir = Path(cleanScriptDir).join(DEBUG).toString()
    }
    if (!deleteDirectory(cleanScriptDir)) {
        return false
    }

    return cleanCov(rootPath)
}

func getConfigFileDir(rootPath: String, tomlInfo: TomlInfo): (Bool, String) {
    if (tomlInfo.isPkgConfig) {
        if (!replaceEnvforTargetDir(tomlInfo, Path(rootPath).join(CONFIG_FILE_NAME).toString())) {
            return (false, "")
        }
        return (true, tomlInfo.pkg.targetDir)
    } else {
        if (!verifyTargetDir(rootPath, tomlInfo.workspace.targetDir)) {
            return (false, "")
        }
        return (true, COMMON_INFO.targetDir)
    }
}

func getConfigScriptFileDir(rootPath: String, tomlInfo: TomlInfo): Option<String> {
    if (tomlInfo.isPkgConfig) {
        if (!replaceEnvforScriptDir(tomlInfo, Path(rootPath))) {
            return Option.None
        }
        return Option.Some(tomlInfo.pkg.scriptDir)
    } else {
        if (!setScriptDir(rootPath, tomlInfo.workspace.scriptDir)) {
            return Option.None
        }
        return Option.Some(COMMON_INFO.scriptDir)
    }
}

func cleanCov(rootPath: String): Bool {
    if (!deleteDirectory(DIR_COV_OUTPUT)) {
        return false
    }

    /*
     * The gcno files generated by cjpm build cannot be moved. The reason why the gcno file cannot be moved is as follows:
     * Assume that the gcno files is generated in '/workdir/testdir', moved gcno files to '/workdir/testdir/subdir'.
     * After user executes the main program, the gcda files are still generated in '/workdir/testdir'.
     * So that gcno files and gcda files are not in the same directory, which will cause a problem.
     */
    let suffixes: ArrayList<String> = ArrayList<String>([".gcno", ".gcda"])
    for (subFile in getFileList(rootPath)) {
        var filePath = subFile.path.toString()
        for (suffix in suffixes) {
            if (filePath.endsWith(suffix)) {
                remove(filePath)
            }
        }
    }
    return true
}

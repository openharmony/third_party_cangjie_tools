// Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

// The Cangjie API is in Beta. For details on its capabilities and limitations, please refer to the README file.

package cjpm.toml

import std.collection.*
import std.convert.Parsable
import std.regex.*
import std.time.{DateTime, TimeParseException, TimeZone}

let TOML_STRING: TomlBaseType = TomlBaseType("String")
let TOML_INTEGER: TomlBaseType = TomlBaseType("Integer")
let TOML_FLOAT: TomlBaseType = TomlBaseType("Float")
let TOML_BOOL: TomlBaseType = TomlBaseType("Bool")

// let tomlDatetime: TomlBaseType = TomlBaseType("Datetime")
let TOML_OFFSET_DATETIME: TomlBaseType = TomlBaseType("OffsetDatetime")
let TOML_LOCAL_DATETIME: TomlBaseType = TomlBaseType("LocalDatetime")
let TOML_LOCAL_DATE: TomlBaseType = TomlBaseType("LocalDate")
let TOML_LOCAL_TIME: TomlBaseType = TomlBaseType("LocalTime")
let TOML_ARRAY: TomlBaseType = TomlBaseType("Array")
let TOML_TABLE: TomlBaseType = TomlBaseType("Table")
let TOML_ARRAY_TABLES: TomlBaseType = TomlBaseType("ArrayTables")

let DATE_TIME_FORMATS = [
    ("yyyy-MM-dd", TOML_LOCAL_DATE),
    ("HH:mm:ss", TOML_LOCAL_TIME),
    ("HH:mm:ss.SS", TOML_LOCAL_TIME),
    ("yyyy-MM-ddTHH:mm:ss", TOML_LOCAL_DATETIME),
    ("yyyy-MM-ddTHH:mm:ss.SS", TOML_LOCAL_DATETIME),
    ("yyyy-MM-ddTHH:mm:ssO", TOML_OFFSET_DATETIME),
    ("yyyy-MM-ddTHH:mm:ssOOOO", TOML_OFFSET_DATETIME),
    ("yyyy-MM-ddTHH:mm:ssz", TOML_OFFSET_DATETIME),
    ("yyyy-MM-ddTHH:mm:sszzzz", TOML_OFFSET_DATETIME),
    ("yyyy-MM-ddTHH:mm:ssZ", TOML_OFFSET_DATETIME),
    ("yyyy-MM-ddTHH:mm:ssZZZZ", TOML_OFFSET_DATETIME),
    ("yyyy-MM-ddTHH:mm:ss.SSO", TOML_OFFSET_DATETIME),
    ("yyyy-MM-ddTHH:mm:ss.SSOOOO", TOML_OFFSET_DATETIME),
    ("yyyy-MM-ddTHH:mm:ss.SSz", TOML_OFFSET_DATETIME),
    ("yyyy-MM-ddTHH:mm:ss.SSzzzz", TOML_OFFSET_DATETIME),
    ("yyyy-MM-ddTHH:mm:ss.SSZ", TOML_OFFSET_DATETIME),
    ("yyyy-MM-ddTHH:mm:ss.SSZZZZ", TOML_OFFSET_DATETIME)
]
let TIME_FORMATS = [("HH:mm:ss.SS", TOML_LOCAL_TIME, #"([01]\d|2[0-3]):([0-5]\d):([0-5]\d)([.,][0-9]{3,9})?"#)]

public struct KeyInfo {
    var pos: Position
    var tomlType: TomlType
    init(tomlType: TomlType, pos: Position) {
        this.tomlType = tomlType
        this.pos = pos
    }
}

public func parse(data: String): Parser {
    var buf = data.toArray()

    // exclude utf-8 bom
    if (buf[0..3] == [0xEF, 0xBB, 0xBF]) {
        buf = buf[3..]
    }
    match (buf.indexOf(0)) {
        case None => ()
        case Some(idx) => throw Exception(
            "files cannot contain NULL bytes; probably using UTF-16; TOML files must be UTF-8")
    }
    let lex = Lexer(buf)
    let p = Parser(lex)
    while (true) {
        let item = p.next()
        if (item.typ == ITEMTYPE.EOF) {
            break
        }
        p.topLevel(item)
    }
    return p
}

public class Parser {
    let lex: Lexer
    var context = Key()
    var currentKey: String = ""
    var pos = Position(0, 0, 0)
    let ordered = ArrayList<Key>()
    let keyInfo = HashMap<String, KeyInfo>()
    let mapping = TomlObject()
    let implicits = HashSet<String>()
    let comments = Comment()

    init(lex: Lexer) {
        this.lex = lex
    }

    func next(): Item {
        let it = lex.nextItem()

        if (it.typ == ITEMTYPE.ERROR) {
            ifSome(it.err, {e => throw ParseException(e.message, it.pos, this.current())})
            throw ParseException(it.val, it.pos)
        }
        return it
    }

    func nextPos(): Item {
        let it = next()
        this.pos = it.pos
        return it
    }

    func expect(typ: ITEMTYPE): Item {
        let it = next()
        assertEqual(typ, it.typ)
        return it
    }

    func assertEqual(expected: ITEMTYPE, got: ITEMTYPE) {
        if (expected != got) {
            throw ParseException("Expected '${expected}' but got '${got}'.")
        }
    }

    func topLevel(item: Item): Unit {
        match (item.typ) {
            // # ..
            case ITEMTYPE.COMMENTSTART =>
                let comment = this.expect(ITEMTYPE.TEXT)
                comments.append(comment.val)

            // [ .. ]
            case ITEMTYPE.TABLESTART =>
                var name = this.nextPos()
                var key = Key()
                while (name.typ != ITEMTYPE.TABLEEND && name.typ != ITEMTYPE.EOF) {
                    key.append(keyString(name))
                    name = next()
                }
                assertEqual(ITEMTYPE.TABLEEND, name.typ)
                addContext(key, false, item.pos)
                setType("", TOML_TABLE, item.pos)
                ordered.add(key)

            // [[ .. ]]
            case ITEMTYPE.ARRAYTABLESTART =>
                var name = this.nextPos()

                var key = Key()
                while (name.typ != ITEMTYPE.ARRAYTABLEEND && name.typ != ITEMTYPE.EOF) {
                    key.append(keyString(name))
                    name = next()
                }
                assertEqual(ITEMTYPE.ARRAYTABLEEND, name.typ)
                addContext(key, true, item.pos)
                setType("", TOML_ARRAY_TABLES, item.pos)
                ordered.add(key)

            // key = ..
            case ITEMTYPE.KEYSTART =>
                let outerContext = this.context.clone()
                var k = nextPos()
                var key = Key()
                while (k.typ != ITEMTYPE.KEYEND && k.typ != ITEMTYPE.EOF) {
                    key.append(keyString(k))
                    k = next()
                }
                assertEqual(ITEMTYPE.KEYEND, k.typ)

                this.currentKey = key[key.size - 1]

                let context = key[0..key.size - 1]
                for (i in 0..context.size) {
                    addImplicitContext(this.context.cloneAppend(context[i..i + 1]), item.pos)
                }
                this.ordered.add(this.context.add(currentKey))

                let vItem = next()
                let (val, typ) = this.value(vItem, false)
                set(currentKey, val, typ, vItem.pos)

                this.context = outerContext
                this.currentKey = ""

            case _ => throw ParseException("Unexpected type at top level: ${item.typ}")
        }
        return
    }

    func keyString(it: Item): String {
        match (it.typ) {
            case ITEMTYPE.TEXT => return it.val
            case ITEMTYPE.STRING | ITEMTYPE.MULTILINESTRING | ITEMTYPE.RAWSTRING | ITEMTYPE.RAWMULTILINESTRING =>
                let (s, _) = this.value(it, false)
                match (s) {
                    case v: TomlString => return v.value
                    case _ => throw ParseException("Unexpected key type")
                }
            case _ => throw ParseException("Unexpected key type ${it.typ}")
        }
        throw ParseException("unreachable")
    }

    func value(it: Item, parentIsArray: Bool): (TomlValue, TomlType) {
        match (it.typ) {
            case ITEMTYPE.STRING => return (TomlString(this.replaceEscapes(it, it.val)), this.typeOfPrimitive(it))
            case ITEMTYPE.MULTILINESTRING => return (TomlString(
                    replaceEscapes(it, stripFirstNewline(stripEscapedNewlines(it.val)))), this.typeOfPrimitive(it))
            case ITEMTYPE.RAWSTRING => return (TomlString(it.val), this.typeOfPrimitive(it))
            case ITEMTYPE.RAWMULTILINESTRING => return (TomlString(stripFirstNewline(it.val)), this.typeOfPrimitive(it))
            case ITEMTYPE.INTEGER =>
                let (v, t) = valueInteger(it)
                return (TomlInteger(v), t)
            case ITEMTYPE.FLOAT =>
                let (v, t) = valueFloat(it)
                return (TomlFloat(v), t)
            case ITEMTYPE.BOOL => match (it.val) {
                case "true" => return (TomlBoolean(true), TOML_BOOL)
                case "false" => return (TomlBoolean(false), TOML_BOOL)
                case _ => throw ParseException("Expected boolean value, but got '${it.val}'.")
            }
            case ITEMTYPE.DATETIME =>
                let (v, t) = valueDatetime(it)
                match {
                    case t.toString() == TOML_LOCAL_TIME.toString() =>
                        let lt = LocalTime(v.hour, v.minute, v.second, nanosecond: v.nanosecond)
                        return (TomlLocalTime(lt), t)
                    case t.toString() == TOML_LOCAL_DATE.toString() =>
                        let ld = LocalDate(v.year, v.month, v.dayOfMonth)
                        return (TomlLocalDate(ld), t)
                    case t.toString() == TOML_LOCAL_DATETIME.toString() =>
                        let lt = LocalTime(v.hour, v.minute, v.second, nanosecond: v.nanosecond)
                        let ld = LocalDate(v.year, v.month, v.dayOfMonth)
                        let ldt = LocalDatetime(ld, lt)
                        return (TomlLocalDatetime(ldt), t)
                    case t.toString() == TOML_OFFSET_DATETIME.toString() => return (TomlOffsetDatetime(v), t)
                    case _ => throw ParseException("Expected datetime value, but got '${it.val}|${t}'.")
                }
            case ITEMTYPE.ARRAY =>
                let (v, t) = valueArray(it)
                return (TomlArray(v), t)
            case ITEMTYPE.INLINETABLESTART =>
                let (v, t) = valueInlineTable(it, parentIsArray)
                return (TomlObject(v), t)
            case _ => throw ParseException("Unexpected value type: ${it.typ}")
        }
        throw ParseException("unreachable")
    }

    func valueInteger(it: Item): (Int64, TomlType) {
        if (!numUnderscoresOK(it.val)) {
            throw ParseException(
                "Invalid integer ${it.val}: underscores must be surrounded by digits",
                it.pos,
                current()
            )
        }
        if (numHasLeadingZero(it.val)) {
            throw ParseException("Invalid integer ${it.val}: cannot have leading zeroes", it.pos, current())
        }
        
        try {
            let num = Int64.parse(it.val)
            return (num, this.typeOfPrimitive(it))
        } catch (e: Exception) {
            eprintln(e.message)
            throw ParseException("Invalid integer ${it.val}: out of Int64 range", it.pos, current())
        }
    }

    func valueFloat(it: Item): (Float64, TomlType) {
        let parts = it.val.split({
            c: Rune => match (c) {
                case '.' | 'e' | 'E' => return true
                case _ => return false
            }
        })
        for (part in parts) {
            if (!numUnderscoresOK(part)) {
                throw ParseException(
                    "Invalid float ${it.val}: underscores must be surrounded by digits",
                    it.pos,
                    current()
                )
            }
        }
        if (parts.size > 0 && numHasLeadingZero(parts[0])) {
            throw ParseException("Invalid float ${it.val}: cannot have leading zeroes", it.pos, current())
        }
        if (!numPeriodsOK(it.val)) {
            throw ParseException(
                "Invalid float ${it.val}: '.' must be followed by one or more digits",
                it.pos,
                current()
            )
        }
        var val = it.val.replace("_", "")
        if (val == "+nan" || val == "-nan") {
            val = "nan"
        }

        try {
            let num = Float64.parse(val)
            return (num, this.typeOfPrimitive(it))
        } catch (e: Exception) {
            eprintln(e.message)
            throw ParseException("Invalid integer ${it.val}: out of Float64 range", it.pos, current())
        }
    }

    func checkTimeFormats(regex: String, val: String): ?DateTime {
        try {
            match (Regex(regex).find(val, group: true)) {
                case Some(s) =>
                    var hour = 0
                    var minute = 0
                    var second = 0
                    var nanosecond = 0
                    if (s.groupCount() == 3) {
                        hour = Int64.tryParse(s.matchString(1)) ?? 0
                        minute = Int64.tryParse(s.matchString(2)) ?? 0
                        second = Int64.tryParse(s.matchString(3)) ?? 0
                    }
                    if (s.groupCount() == 4) {
                        nanosecond = Int64.tryParse(s.matchString(4)[1..]) ?? 0
                    }
                    let t = DateTime.of(
                        year: 1,
                        month: 1,
                        dayOfMonth: 1,
                        hour: hour,
                        minute: minute,
                        second: second,
                        nanosecond: nanosecond,
                        timeZone: TimeZone.Local
                    )
                    return t
                case _ => ()
            }
        } catch (tpe: TimeParseException) {} catch (iobe: IndexOutOfBoundsException) {}

        return None
    }

    func valueDatetime(it: Item): (DateTime, TomlType) {
        // Offset Date-Time
        // Local Date-Time
        // Local Date
        // Local Time
        var val = datetimeReplace(it.val)
        for ((fmt, typ) in DATE_TIME_FORMATS) {
            try {
                let t = DateTime.parse(val, fmt)
                return (t, typ)
            } catch (tpe: TimeParseException) {} catch (iobe: IndexOutOfBoundsException) {}
        }

        for ((_, typ, regex) in TIME_FORMATS) {
            if (let Some(t) <- this.checkTimeFormats(regex, val)) {
                return (t, typ)
            }
        }

        throw ParseException(
            "Invalid TOML Datetime: ${it.val}.",
            it.pos,
            current()
        )
    }

    func valueArray(it: Item): (ArrayList<TomlValue>, TomlType) {
        this.setType(this.currentKey, TOML_ARRAY, it.pos)

        var types = ArrayList<TomlType>()
        var array = ArrayList<TomlValue>()
        var item = this.next()
        while (item.typ != ITEMTYPE.ARRAYEND) {
            if (item.typ == ITEMTYPE.COMMENTSTART) {
                let comment = this.expect(ITEMTYPE.TEXT)
                comments.append(comment.val)
            } else {
                let (val, typ) = this.value(item, true)
                array.add(val)
                types.add(typ)
            }
            item = this.next()
        }
        return (array, TOML_ARRAY)
    }

    func valueInlineTable(it: Item, parentIsArray: Bool): (LinkedHashMap<String, TomlValue>, TomlType) {
        let topHash = LinkedHashMap<String, TomlValue>()
        var outerContext = this.context.clone()
        var outerKey = this.currentKey

        this.context.append(this.currentKey)
        let prevContext = this.context.clone()
        this.currentKey = ""

        this.addImplicit(this.context)
        this.addContext(this.context, parentIsArray, it.pos)

        var item = this.next()
        while (item.typ != ITEMTYPE.INLINETABLEEND) {
            if (item.typ == ITEMTYPE.COMMENTSTART) {
                let comment = this.expect(ITEMTYPE.TEXT)
                comments.append(comment.val)
                item = this.next()
                continue
            }
            var k = this.nextPos()
            var key = Key()
            while (k.typ != ITEMTYPE.KEYEND && k.typ != ITEMTYPE.EOF) {
                key.append(this.keyString(k))
                k = this.next()
            }
            this.assertEqual(ITEMTYPE.KEYEND, k.typ)
            this.currentKey = key[key.size - 1]
            let context = key[0..key.size - 1]
            for (i in 0..context.size) {
                this.addImplicitContext(this.context.cloneAppend(context[i..i + 1]), item.pos)
            }
            this.ordered.add(this.context.add(this.currentKey))

            let (val, typ) = this.value(this.next(), false)
            this.set(this.currentKey, val, typ, item.pos)

            var hash = topHash
            for (ctx in context) {
                var h = hash.get(ctx)
                match (h) {
                    case Some(tv) => hash = tv.asObject().value
                    case None =>
                        let to = TomlObject()
                        hash[ctx] = to
                        hash = to.value
                }
                hash = hash[ctx].asObject().value
            }
            hash[this.currentKey] = val
            this.context = prevContext
            item = this.next()
        }
        this.context = outerContext
        this.currentKey = outerKey
        return (topHash, TOML_TABLE)
    }

    func addContext(key: Key, array: Bool, pos: Position): Unit {
        let myKey = key.clone()

        var hashContext = this.mapping
        let keyContext = Key()
        for (i in 0..myKey.size - 1) {
            let k = myKey[i]
            keyContext.append(k)
            if (!hashContext.contains(k)) {
                addImplicit(keyContext)
                hashContext.put(k, TomlObject())
            }
            match (hashContext.get(k)) {
                case Some(v) => match (v) {
                    case jo: TomlObject => hashContext = jo
                    case ja: TomlArray =>
                        let jv = ja[ja.size - 1]
                        hashContext = jv.asObject()
                    case _ => throw ParseException("Key '${keyContext}' was already created as a hash.")
                }
                case _ => ()
            }
        }
        this.context = keyContext
        if (array) {
            let k = myKey[myKey.size - 1]
            if (!hashContext.contains(k)) {
                hashContext.put(k, TomlArray())
            }
            match (hashContext.get(k)) {
                case Some(v) => match (v) {
                    case hash: TomlArray => hash.append(TomlObject())
                    case _ => throw ParseException(
                        "Key '${keyContext}' was already created and cannot be used as an array.")
                }
                case _ => throw ParseException(
                    "Key '${keyContext}' was already created and cannot be used as an array.")
            }
        } else {
            setValue(myKey[myKey.size - 1], TomlObject(), pos)
        }
        context.append(myKey[myKey.size - 1])
    }

    func set(key: String, val: TomlValue, typ: TomlType, pos: Position) {
        setValue(key, val, pos)
        setType(key, typ, pos)
    }

    func setValue(key: String, value: TomlValue, pos: Position) {
        if (!comments.isEmpty()) {
            value.comment.append(comments)
            comments.clear()
        }
        var tmpHash: TomlValue
        var hash = this.mapping
        var keyContext = Key()

        for (k in this.context) {
            keyContext.append(k)
            match (hash.get(k)) {
                case None => throw ParseException("Context for key '${keyContext}' has not been established.", pos)
                case Some(v) => tmpHash = v
            }
            match (tmpHash) {
                // TomlArray is ArrayList<TomlObject>
                case ja: TomlArray =>
                    let jv = ja[ja.size - 1]
                    let jo = jv.asObject()
                    hash = jo

                // TomlObject is HashMap<String, TomlValue>
                case ha: TomlObject => hash = ha
                case _ => throw ParseException("Key '${keyContext}' has already been defined.", pos)
            }
        }
        keyContext.append(key)
        if (hash.contains(key)) {
            if (isImplicit(keyContext)) {
                removeImplicit(keyContext)
                return
            }
            throw ParseException("Key '${keyContext}' has already been defined.", pos)
        }
        hash.put(key, value)
    }

    func setType(key: String, typ: TomlType, pos: Position) {
        var keyContext = Key(context.size + 1)
        keyContext.append(context)
        if (key.size > 0) {
            keyContext.append(key)
        }
        if (keyContext.size == 0) {
            keyContext = Key([""])
        }
        this.keyInfo[keyContext.toString()] = KeyInfo(typ, pos)
    }

    func addImplicit(key: Key) {
        implicits.add(key.toString())
    }

    func removeImplicit(key: Key) {
        implicits.remove(key.toString())
    }

    func isImplicit(key: Key): Bool {
        return implicits.contains(key.toString())
    }

    func addImplicitContext(key: Key, pos: Position) {
        addImplicit(key)
        addContext(key, false, pos)
    }

    func current(): String {
        if (currentKey.size == 0) {
            return this.context.toString()
        }
        if (context.size == 0) {
            return currentKey
        }
        return "${context}.${currentKey}"
    }

    func stripEscapedNewlines(s: String): String {
        let split = s.split("\n")
        if (split.size < 1) {
            return s
        }
        var escNL = false
        for (i in 0..split.size) {
            var line = split[i]
            line = line.stripRight(" \t\r")
            if (line.size == 0 || line[line.size - 1] != b'\\') {
                split[i] = split[i].stripRight("\r")
                if (!escNL && i != split.size - 1) {
                    split[i] += "\n"
                }
                continue
            }

            var escBS = true
            for (j in line.size - 1..=0 : -1) {
                if (line[j] == b'\\') {
                    escBS = !escBS
                }
            }
            if (escNL) {
                line = line.stripLeft(" \t\r")
            }
            escNL = !escBS
            if (escBS) {
                split[i] += "\n"
                continue
            }
            if (i == split.size - 1) {
                throw ParseException("invalid escape: '\\ '")
            }
            split[i] = line[0..line.size - 1]
            if (split.size - 1 > i) {
                split[i + 1] = split[i + 1].stripLeft(" \t\r")
            }
        }
        return String.join(split, delimiter: "")
    }

    func replaceEscapes(it: Item, str: String): String {
        let replaced = ArrayList<Rune>(str.size)
        let s = str.toArray()
        var r = 0
        while (r < s.size) {
            if (s[r] != b'\\') {
                let (c, size) = Rune.fromUtf8(s[0..], r)
                r += size
                replaced.add(c)
                continue
            }
            r += 1
            if (r >= s.size) {
                throw ParseException("BUG: Escape sequence at end of string.")
            }
            match (s[r]) {
                case ' ' | '\t' => throw ParseException("invalid escape: '\\${s[r]}'", it.pos)
                case 'b' =>
                    replaced.add(Rune(8))
                    r += 1
                case 't' =>
                    replaced.add(Rune(9))
                    r += 1
                case 'n' =>
                    replaced.add(Rune(0xA))
                    r += 1
                case 'f' =>
                    replaced.add(Rune(0xC))
                    r += 1
                case 'r' =>
                    replaced.add(Rune(0xD))
                    r += 1
                case 'e' => ()
                case '"' =>
                    replaced.add(Rune(0x22))
                    r += 1
                case '\\' =>
                    replaced.add(Rune(0x5C))
                    r += 1
                case 'x' => ()
                case 'u' =>
                    let escaped = asciiEscapeToUnicode(it, s[r + 1..r + 5])
                    replaced.add(escaped)
                    r += 5
                case 'U' =>
                    let escaped = asciiEscapeToUnicode(it, s[r + 1..r + 9])
                    replaced.add(escaped)
                    r += 9
                case _ => throw ParseException("Expected valid escape code after \\, but got ${s[r]}.", it.pos)
            }
        }
        return String(replaced)
    }

    func typeOfPrimitive(it: Item): TomlType {
        match (it.typ) {
            case ITEMTYPE.INTEGER => return TOML_INTEGER
            case ITEMTYPE.FLOAT => return TOML_FLOAT
            case ITEMTYPE.STRING => return TOML_STRING
            case ITEMTYPE.MULTILINESTRING => return TOML_STRING
            case ITEMTYPE.RAWSTRING => return TOML_STRING
            case ITEMTYPE.RAWMULTILINESTRING => return TOML_STRING
            case ITEMTYPE.BOOL => return TOML_BOOL
            case _ => throw ParseException("Cannot infer primitive type of lex item '${it.typ}'.")
        }
    }
}

func numHasLeadingZero(s: String): Bool {
    if (s.size > 1 && s[0] == b'0' && !(s[1] == b'b' || s[1] == b'o' || s[1] == b'x')) {
        return true
    }
    if (s.size > 2 && (s[0] == b'-' || s[0] == b'+') && s[1] == b'0') {
        return true
    }
    return false
}

func numUnderscoresOK(s: String): Bool {
    match (s) {
        case "nan" | "+nan" | "-nan" | "inf" | "-inf" | "+inf" => return true
        case _ => ()
    }
    var accept = false
    for (c in s.runes()) {
        if (c == r'_') {
            if (!accept) {
                return false
            }
        }
        accept = isHexadecimal(c)
    }
    return accept
}

func numPeriodsOK(s: String): Bool {
    var period = false
    for (c in s.runes()) {
        if (period && !isDigit(c)) {
            return false
        }
        period = (c == r'.')
    }
    return !period
}

func stripFirstNewline(s: String) {
    if (s.size > 0 && s[0] == b'\n') {
        return s[1..]
    }
    if (s.size > 1 && s[0] == b'\r' && s[1] == b'\n') {
        return s[2..]
    }
    return s
}

func asciiEscapeToUnicode(it: Item, bs: Array<Byte>): Rune {
    let s = String.fromUtf8(bs)
    if (let Some(u) <- UInt32.tryParse("0x${s}")) {
        if (!validChar(Rune(u))) {
            throw ParseException("Escaped character '\\u${s}' is not valid UTF-8.", it.pos)
        }
        return Rune(u)
    }
    throw ParseException("Escaped character '\\u${s}' is not valid UTF-8.", it.pos)
}

// Copyright (c) Huawei Technologies Co., Ltd. 2026. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

// The Cangjie API is in Beta. For details on its capabilities and limitations, please refer to the README file.

package my_module

import std.collection.{concurrent.ConcurrentHashMap, HashMap}
import ohos.base.UIThread
import ohos.hilog.Hilog
import std.sync.Mutex
import ohos.ark_interop.*
import std.convert.Parsable
import std.env.getProcessId

foreign func gettid(): Int64

const JS_INTERNAL_ERROR = -1i32
protected let EMPTY_ARG = {_: JSContext => Array<JSValue>()}
private let MAIN_CONTEXT_MODULE_MAP = ConcurrentHashMap<String, JSObject>()
protected var mainThreadRuntime = None<JSRuntime>
protected var mainThreadContext = None<JSContext>
private var lock = Mutex()
private let mainThreadId = getProcessId()
// only run in hybrid mode
private let _ = JSModule.registerModule {
    ctx, _ => mainThreadContext = ctx
}

protected func getMainContext(): JSContext {
    // hybrid mode
    if (let Some(v) <- mainThreadContext) {
        return v
    }
    // pure cj, create js runtime in main thread
    // user may call this func in spawn

    func initJs(): JSContext {
        synchronized(lock) {
            if (let Some(v) <- mainThreadContext) {
                v
            } else {
                let rt = JSRuntime()
                mainThreadRuntime = rt
                mainThreadContext = rt.mainContext
                rt.mainContext
            }
        }
    }

    let curTid = getProcessId()
    if (curTid == mainThreadId) {
        initJs()
    } else {
        let f = spawn (UIThread) {
            initJs()
        }
        f.get()
    }
}

protected func checkThreadAndCall<T>(ctx: JSContext, f: (JSContext) -> T): T {
    if (ctx.isInBindThread()) {
        f(ctx)
    } else {
        let fut = spawn (UIThread) {
            f(ctx)
        }
        fut.get()
    }
}

func handleError(ctx: JSContext, err: JSValue): BusinessException {
    if (err.isObject()) {
        let errObj = err.asObject()
        let code = if (errObj["code"].isNumber()) {
            Int32.fromJSValue(ctx, errObj.getProperty("code"))
        } else if (errObj["code"].isString()) {
            Int32.tryParse(String.fromJSValue(ctx, errObj["code"])) ?? JS_INTERNAL_ERROR
        } else {
            JS_INTERNAL_ERROR
        }
        let msg = if (errObj["message"].isString()) {
            String.fromJSValue(ctx, errObj["message"])
        } else {
            "unknown exception occured"
        }
        BusinessException(code, msg)
    } else if (err.isNumber()) {
        let code = Int32.fromJSValue(ctx, err)
        BusinessException(code, "unknown exception occured")
    } else {
        BusinessException(JS_INTERNAL_ERROR, "unknown exception occured")
    }
}

protected func asyncCallbackWrapper<T>(ctx: JSContext, callback: (?BusinessException, ?T) -> Unit,
    onResolve: (JSContext, JSValue) -> T): JSValue {
    func call(ctx: JSContext): JSValue {
        let jscall = ctx.function {
            ctx, info =>
            try {
                var err = None<BusinessException>
                var data = None<T>
                if (!info[0].isNull() && !info[0].isUndefined()) {
                    err = handleError(ctx, info[0])
                } else {
                    data = onResolve(ctx, info[1])
                }
                callback(err, data)
            } catch (e: Exception) {
                Hilog.error(0xD003903, "Cangjie-App", "${e}")
                throw e
            }
            ctx.undefined().toJSValue()
        }
        jscall.toJSValue()
    }
    checkThreadAndCall<JSValue>(ctx, call)
}

protected func asyncCallbackWrapper<T>(ctx: JSContext, callback: (?BusinessException, ?T) -> Unit): JSValue where T <: JSInteropType<T> {
    asyncCallbackWrapper<T>(ctx, callback) {ctx, info => T.fromJSValue(ctx, info)}
}

protected func asyncCallbackWrapperEx<T>(ctx: JSContext, callback: AsyncCallback<T>,
    paramParser: (JSContext, JSValue) -> T): JSValue {
    func call(ctx: JSContext): JSValue {
        let jscall = ctx.function {
            ctx, info =>
            try {
                var err = None<BusinessException>
                var data = None<T>
                if (info[1].isNull() || info[1].isUndefined()) {
                    err = handleError(ctx, info[0])
                } else {
                    data = paramParser(ctx, info[1])
                }
                callback(err, data)
            } catch (e: Exception) {
                Hilog.error(1, "hle", e.toString())
                throw e
            }
            ctx.undefined().toJSValue()
        }
        jscall.toJSValue()
    }
    checkThreadAndCall<JSValue>(ctx, call)
}

protected func getJSModule(ctx: JSContext, name: String, prefix: ?String): JSObject {
    match (MAIN_CONTEXT_MODULE_MAP.get(name)) {
        case Some(v) => v
        case None =>
            let module = ctx.global[name].asObject()
            MAIN_CONTEXT_MODULE_MAP.add(name, module)
            module
    }
}

protected func toJSFunction(fun: () -> Unit): JSValue {
    func call(ctx: JSContext): JSValue {
        let jsFun = ctx.function {
            ctx, info =>
            fun()
            ctx.undefined().toJSValue()
        }
        jsFun.toJSValue()
    }
    checkThreadAndCall<JSValue>(getMainContext(), call)
}

protected func toJSFunction<T>(fun: (T) -> Unit): JSValue where T <: JSInteropType<T> {
    toJSFunction(fun, {ctx, info => T.fromJSValue(ctx, info)})
}

protected func toJSFunction<T>(fun: (T) -> Unit, paramParser: (JSContext, JSValue) -> T): JSValue {
    func call(ctx: JSContext): JSValue {
        let jsFun = ctx.function {
            ctx, info =>
            fun(paramParser(ctx, info[0]))
            ctx.undefined().toJSValue()
        }
        jsFun.toJSValue()
    }
    checkThreadAndCall<JSValue>(getMainContext(), call)
}

protected func toJSFunction<T, P>(fun: (T, P) -> Unit, paramParser1: (JSContext, JSValue) -> T,
    paramParser2: (JSContext, JSValue) -> P): JSValue {
    func call(ctx: JSContext): JSValue {
        let jsFun = ctx.function {
            ctx, info =>
            fun(paramParser1(ctx, info[0]), paramParser2(ctx, info[1]))
            ctx.undefined().toJSValue()
        }
        jsFun.toJSValue()
    }
    checkThreadAndCall<JSValue>(getMainContext(), call)
}

protected func toJSFunction<P1, P2, P3>(fun: (P1, P2, P3) -> Unit, paramParser1: (JSContext, JSValue) -> P1,
    paramParser2: (JSContext, JSValue) -> P2, paramParser3: (JSContext, JSValue) -> P3): JSValue {
    func call(ctx: JSContext): JSValue {
        let jsFun = ctx.function {
            ctx, info =>
            fun(paramParser1(ctx, info[0]), paramParser2(ctx, info[1]), paramParser3(ctx, info[2]))
            ctx.undefined().toJSValue()
        }
        jsFun.toJSValue()
    }
    checkThreadAndCall<JSValue>(getMainContext(), call)
}

protected func toJSFunctionWithReturn<P1, P2, R>(fun: (P1, P2) -> R, paramParser1: (JSContext, JSValue) -> P1,
    paramParser2: (JSContext, JSValue) -> P2, retParser: (JSContext, R) -> JSValue): JSValue {
    func call(ctx: JSContext): JSValue {
        let jsFun = ctx.function {
            ctx, info => retParser(ctx, fun(paramParser1(ctx, info[0]), paramParser2(ctx, info[1])))
        }
        jsFun.toJSValue()
    }
    checkThreadAndCall<JSValue>(getMainContext(), call)
}

protected func toJSFunctionWithReturn<T, P, J, K>(fun: (T, P, J) -> K, param1Parser: (JSContext, JSValue) -> T,
    param2Parser: (JSContext, JSValue) -> P, param3Parser: (JSContext, JSValue) -> J,
    retParser: (JSContext, K) -> JSValue): JSValue {
    func call(ctx: JSContext): JSValue {
        let jsFun = ctx.function {
            ctx, info => retParser(ctx,
                fun(param1Parser(ctx, info[0]), param2Parser(ctx, info[1]), param3Parser(ctx, info[2])))
        }
        jsFun.toJSValue()
    }
    checkThreadAndCall<JSValue>(getMainContext(), call)
}

protected func fromJSFunction<T>(ctx: JSContext, fun: JSValue): (T) -> Unit where T <: JSInteropType<T> {
    fromJSFunction(ctx, fun, {ctx, val => val.toJSValue(ctx)})
}

protected func fromJSFunction<T>(ctx: JSContext, fun: JSValue, paramParser: (JSContext, T) -> JSValue): (T) -> Unit {
    {
        val: T => checkThreadAndCall<Unit>(ctx, {ctx => fun.asFunction().call([paramParser(ctx, val)])})
    }
}

protected func fromJSFunctionWithReturn<T, P, K>(ctx: JSContext, fun: JSValue,
    param1Parser: (JSContext, T) -> JSValue, param2Parser: (JSContext, P) -> JSValue,
    retParser: (JSContext, JSValue) -> K): (T, P) -> K {
    {
        val1: T, val2: P => checkThreadAndCall<K>(
            ctx,
            {
                ctx => retParser(ctx,
                    fun.asFunction().call([param1Parser(ctx, val1), param2Parser(ctx, val2)]))
            }
        )
    }
}

protected func fromJSFunctionWithReturn<T, P, J, K>(ctx: JSContext, fun: JSValue,
    param1Parser: (JSContext, T) -> JSValue, param2Parser: (JSContext, P) -> JSValue,
    param3Parser: (JSContext, J) -> JSValue, retParser: (JSContext, JSValue) -> K): (T, P, J) -> K {
    {
        val1: T, val2: P, val3: J => checkThreadAndCall<K>(
            ctx,
            {
                ctx => retParser(ctx,
                    fun.asFunction().call([param1Parser(ctx, val1), param2Parser(ctx, val2), param3Parser(ctx, val3)]))
            }
        )
    }
}

protected func fromJSFunction<T, P>(ctx: JSContext, fun: JSValue, paramParser1: (JSContext, T) -> JSValue,
    paramParser2: (JSContext, P) -> JSValue): (T, P) -> Unit {
    {
        val1: T, val2: P => checkThreadAndCall<Unit>(ctx,
            {ctx => fun.asFunction().call([paramParser1(ctx, val1), paramParser2(ctx, val2)])})
    }
}

protected func fromJSFunction<P1, P2, P3>(ctx: JSContext, fun: JSValue, paramParser1: (JSContext, P1) -> JSValue,
    paramParser2: (JSContext, P2) -> JSValue, paramParser3: (JSContext, P3) -> JSValue): (P1, P2, P3) -> Unit {
    {
        val1: P1, val2: P2, val3: P3 => checkThreadAndCall<Unit>(ctx,
            {ctx => fun.asFunction().call([paramParser1(ctx, val1), paramParser2(ctx, val2), paramParser3(ctx, val3)])})
    }
}

protected func jsGlobalApiCall<T>(moduleName: String, modulePrefix: ?String, funcName: String,
    args: (JSContext) -> Array<JSValue>, onResolve: (JSContext, JSValue) -> T): T {
    func call(context: JSContext): T {
        try {
            let jsModule = getJSModule(context, moduleName, modulePrefix)
            let jsRet = jsModule.callMethod(funcName, args(context))
            onResolve(context, jsRet)
        } catch (e: BusinessException) {
            throw e
        }
    }
    checkThreadAndCall<T>(getMainContext(), call)
}

protected func jsObjApiCall<T>(obj: JSObject, funcName: String, args: (JSContext) -> Array<JSValue>,
    onResolve: (JSContext, JSValue) -> T): T {
    func call(context: JSContext): T {
        try {
            let jsRet = obj.callMethod(funcName, args(context))
            onResolve(context, jsRet)
        } catch (e: BusinessException) {
            throw e
        }
    }
    checkThreadAndCall<T>(getMainContext(), call)
}

protected func hmsGlobalApiCall<T>(moduleName: String, funcName: String, args: (JSContext) -> Array<JSValue>,
    onResolve: (JSContext, JSValue) -> T): T {
    jsGlobalApiCall<T>(moduleName, "hms", funcName, args, onResolve)
}

protected func ohosGlobalApiCall<T>(moduleName: String, funcName: String, args: (JSContext) -> Array<JSValue>,
    onResolve: (JSContext, JSValue) -> T): T {
    jsGlobalApiCall<T>(moduleName, None<String>, funcName, args, onResolve)
}

protected func jsObjApiCall<T>(obj: JSObject, funcName: String, args: (JSContext) -> Array<JSValue>): T where T <: JSInteropType<T> {
    jsObjApiCall<T>(obj, funcName, args) {ctx, info => T.fromJSValue(ctx, info)}
}

protected func hmsGlobalApiCall<T>(moduleName: String, funcName: String, args: (JSContext) -> Array<JSValue>): T where T <: JSInteropType<T> {
    hmsGlobalApiCall<T>(moduleName, funcName, args) {ctx, info => T.fromJSValue(ctx, info)}
}

protected func ohosGlobalApiCall<T>(moduleName: String, funcName: String, args: (JSContext) -> Array<JSValue>): T where T <: JSInteropType<T> {
    ohosGlobalApiCall<T>(moduleName, funcName, args) {ctx, info => T.fromJSValue(ctx, info)}
}

protected func getClassConstructorObj(moduleName: String, className: String, prefix!: ?String = None): JSObject {
    checkThreadAndCall<JSObject>(getMainContext()) {
        ctx =>
        let module = getJSModule(ctx, moduleName, prefix)
        module[className].asObject()
    }
}

protected struct JsGlobalApiCallInfo<T> {
    var moduleName: String
    var modulePrefix: ?String
    var funcName: String
    var callback: (?BusinessException, ?T) -> Unit
    var args: (JSContext) -> Array<JSValue>
    init(moduleName: String, modulePrefix: ?String, funcName: String,
         callback: (?BusinessException, ?T) -> Unit, args: (JSContext) -> Array<JSValue>) {
        this.moduleName = moduleName
        this.modulePrefix = modulePrefix
        this.funcName = funcName
        this.callback = callback
        this.args = args
    }
}

protected func jsGlobalApiCallPromise<T>(jsGlobalApiCallInfo: JsGlobalApiCallInfo<T>, onResolve: (JSContext, JSValue) -> T): Unit {
    func call(context: JSContext): Unit {
        try {
            let jsRet = getJSModule(context, jsGlobalApiCallInfo.moduleName, jsGlobalApiCallInfo.modulePrefix).callMethod(
                jsGlobalApiCallInfo.funcName, jsGlobalApiCallInfo.args(context))
            let promise = jsRet.asPromise()
            let onResolved = context.function(
                {
                    ctx: JSContext, callInfo: JSCallInfo =>
                    try {
                        let result = onResolve(ctx, callInfo[0])
                        jsGlobalApiCallInfo.callback(None, result)
                    } catch (e: BusinessException) {
                        jsGlobalApiCallInfo.callback(e, None)
                    } catch (e: Exception) {
                        jsGlobalApiCallInfo.callback(BusinessException(JS_INTERNAL_ERROR, e.message), None)
                    }
                    ctx.null().toJSValue()
                }
            )
            let onRejected = context.function(
                {
                    ctx: JSContext, callInfo: JSCallInfo =>
                    jsGlobalApiCallInfo.callback(handleError(ctx, callInfo[0]), None)
                    ctx.null().toJSValue()
                }
            )
            promise.then(onResolved, onRejected: onRejected)
        } catch (e: BusinessException) {
            throw e
        }
    }
    checkThreadAndCall<Unit>(getMainContext(), call)
}

protected func jsGlobalApiCallPromise<T>(moduleName: String, modulePrefix: ?String, funcName: String,
    callback: (?BusinessException, ?T) -> Unit, args: (JSContext) -> Array<JSValue>): Unit where T <: JSInteropType<T> {
    jsGlobalApiCallPromise<T>(JsGlobalApiCallInfo<T>(moduleName, modulePrefix, funcName, callback, args)) {
        ctx, value => T.fromJSValue(ctx, value)
    }
}

protected func hmsGlobalApiCallPromise<T>(moduleName: String, funcName: String,
    callback: (?BusinessException, ?T) -> Unit, args: (JSContext) -> Array<JSValue>, onResolve: (JSContext, JSValue) -> T): Unit {
    jsGlobalApiCallPromise<T>(JsGlobalApiCallInfo<T>(moduleName, "hms", funcName, callback, args), onResolve)
}

protected func ohosGlobalApiCallPromise<T>(moduleName: String, funcName: String,
    callback: (?BusinessException, ?T) -> Unit, args: (JSContext) -> Array<JSValue>, onResolve: (JSContext, JSValue) -> T): Unit {
    jsGlobalApiCallPromise<T>(JsGlobalApiCallInfo<T>(moduleName, None, funcName, callback, args), onResolve)
}

protected func hmsGlobalApiCallPromise<T>(moduleName: String, funcName: String,
    callback: (?BusinessException, ?T) -> Unit, args: (JSContext) -> Array<JSValue>): Unit where T <: JSInteropType<T> {
    jsGlobalApiCallPromise<T>(moduleName, "hms", funcName, callback, args)
}

protected func ohosGlobalApiCallPromise<T>(moduleName: String, funcName: String,
    callback: (?BusinessException, ?T) -> Unit, args: (JSContext) -> Array<JSValue>): Unit where T <: JSInteropType<T> {
    jsGlobalApiCallPromise<T>(moduleName, None, funcName, callback, args)
}

protected func jsObjApiCallPromise<T>(obj: JSObject, funcName: String, callback: (?BusinessException, ?T) -> Unit,
    args: (JSContext) -> Array<JSValue>, onResolve: (JSContext, JSValue) -> T): Unit {
    func call(context: JSContext): Unit {
        try {
            let jsRet = obj.callMethod(funcName, args(context))
            let promise = jsRet.asPromise()
            let onResolved = context.function(
                {
                    ctx: JSContext, callInfo: JSCallInfo =>
                    try {
                        let result = onResolve(ctx, callInfo[0])
                        callback(None, result)
                    } catch (e: BusinessException) {
                        callback(e, None)
                    } catch (e: Exception) {
                        callback(BusinessException(JS_INTERNAL_ERROR, e.message), None)
                    }
                    ctx.null().toJSValue()
                }
            )
            let onRejected = context.function(
                {
                    ctx: JSContext, callInfo: JSCallInfo =>
                    callback(handleError(ctx, callInfo[0]), None)
                    ctx.null().toJSValue()
                }
            )
            promise.then(onResolved, onRejected: onRejected)
        } catch (e: BusinessException) {
            throw e
        }
    }
    checkThreadAndCall<Unit>(getMainContext(), call)
}

protected func jsObjApiCallPromise<T>(obj: JSObject, funcName: String, callback: (?BusinessException, ?T) -> Unit,
    args: (JSContext) -> Array<JSValue>): Unit where T <: JSInteropType<T> {
    jsObjApiCallPromise(obj, funcName, callback, args) {ctx, value => T.fromJSValue(ctx, value)}
}

protected func toJSArray<T>(ctx: JSContext, cjArr: ?Array<T>): JSValue where T <: JSInteropType<T> {
    if (let Some(arr) <- cjArr) {
        let jsArr = Array<JSValue>(arr.size) {
            i => arr[i].toJSValue(ctx)
        }
        ctx.array(jsArr).toJSValue()
    } else {
        ctx.undefined().toJSValue()
    }
}

protected func toJSArray<T>(ctx: JSContext, cjArr: ?Array<T>, constructor: (JSContext, T) -> JSValue): JSValue {
    if (let Some(arr) <- cjArr) {
        let jsArr = Array<JSValue>(arr.size) {
            i => constructor(ctx, arr[i])
        }
        ctx.array(jsArr).toJSValue()
    } else {
        ctx.undefined().toJSValue()
    }
}

protected func fromJSArray<T>(ctx: JSContext, input: JSValue): Array<T> where T <: JSInteropType<T> {
    if (input.isUndefined()) {
        return []
    }
    let jsArr = input.asArray()
    Array<T>(jsArr.size) {
        i => T.fromJSValue(ctx, jsArr[i])
    }
}

protected func fromJSArray<T>(ctx: JSContext, input: JSValue, constructor: (JSContext, JSValue) -> T): Array<T> {
    let jsArr = input.asArray()
    return Array<T>(jsArr.size) {
        index => constructor(ctx, jsArr[index])
    }
}

protected func fromJSArrayOption<T>(ctx: JSContext, input: JSValue): Option<Array<T>> where T <: JSInteropType<T> {
    if (input.isUndefined()) {
        None<Array<T>>
    } else {
        Some(fromJSArray<T>(ctx, input))
    }
}

protected func fromJSArrayOption<T>(ctx: JSContext, input: JSValue, constructor: (JSContext, JSValue) -> T): Option<Array<T>> {
    if (input.isUndefined()) {
        None<Array<T>>
    } else {
        Some(fromJSArray(ctx, input, constructor))
    }
}

protected func record2Hashmap<V>(context: JSContext, input: JSValue, valueConstructor: (JSContext, JSValue) -> V): HashMap<String, V> {
    if (input.isUndefined()) {
        HashMap<String, V>()
    } else {
        let record = input.asObject()
        let hashmap = HashMap<String, V>()

        for(key in record.keys()) {
            hashmap.add(key, valueConstructor(context, record[key]))
        }
        hashmap
     }
}

protected func hashmap2Record<K, V>(context: JSContext, hashmap: ?HashMap<K, V>, valueConstructor: (JSContext, V) -> JSValue): JSValue where K <: Hashable & Equatable<K> & JSKeyable {
    if (let Some(map) <- hashmap) {
        let obj = context.object()

        for((k, v) in map) {
            obj.setProperty(k, valueConstructor(context, v))
        }

        obj.toJSValue()
    } else {
        context.undefined().toJSValue()
     }
}

protected func instanceof(value: JSValue, className: String): Bool {
    let ctx = getMainContext()
    let prototype = ctx.global["Object"].asObject().callMethod("getPrototypeOf", [value]).asObject()
    let constructor = prototype["constructor"].asObject()
    return constructor["name"].toString() == className
}

protected func instanceof(value: JSValue, moduleName: String, prefix: ?String, className: String): Bool {
    func innerInstanceof(ctx: JSContext): Bool {
        let clazz = getJSModule(ctx, moduleName, prefix)[ctx.string(className)].asClass()
        value.asObject().instanceOf(clazz)
    }
    checkThreadAndCall<Bool>(getMainContext(), innerInstanceof)
}

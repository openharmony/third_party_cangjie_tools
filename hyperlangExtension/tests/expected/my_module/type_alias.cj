// Copyright (c) Huawei Technologies Co., Ltd. 2026. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

// The Cangjie API is in Beta. For details on its capabilities and limitations, please refer to the README file.

package my_module

import ohos.ark_interop.*
import ohos.ark_interop_helper.*
import ohos.base.*
import std.math.numeric.*
import std.collection.{ HashMap }


public type TA10 = Float64


public type TA20 = String


public type TA30 = Bool


public type TA40 = BigInt


public type TA50 = JSValue/* FIXME: `object` */


public type TA60 = JSValue/* FIXME: `symbol` */


public type TA70 = Unit


public type TA80 = JSValue/* FIXME: `undefined` */


public type TA90 = JSValue/* FIXME: `any` */


public type TA100 = JSValue/* FIXME: `unknown` */


public type TA110 = JSValue/* FIXME: `never` */


public type TA200 = () -> Unit


public type TA210< V > = (V) -> Unit/* FIXME: `<V>(arg: V) => void` */


public type TA220< V, W > = (V) -> W/* FIXME: `<V, W extends string>(arg: V) => W` */


public type TA230< V, W > = (V) -> W/* FIXME: `<V, W extends string>(arg: V) => W` */


public type TA240 = (Array<Float64>) -> Unit


public type TA250 = (?Float64) -> Unit


public type TA300 = JSValue/* FIXME: `Promise<string>` */


public type TA310 = Array<JSValue/* FIXME: `Promise<string>` */>


public type TA400 = JSValue/* FIXME: `Pick` */


public type TA410 = JSValue/* FIXME: `Omit` */


public type TA420 = JSValue/* FIXME: `Omit` */


public type TA500 = JSValue/* FIXME: `123` */


public type TA510 = JSValue/* FIXME: `"abc"` */


public type TA520 = JSValue/* FIXME: `null` */


public type TA600 = (Float64, String, Float64)


public type TA700 = Option<HashMap<String, JSValue/* FIXME: `unknown` */>>


public enum TA710 {
    | AAA
    | BBB
    | CCC
    | DDD
    
    public func toJSValue(context: JSContext): JSValue {
        match(this) {
            case AAA => context.string("aaa").toJSValue()
            case BBB => context.string("bbb").toJSValue()
            case CCC => context.string("ccc").toJSValue()
            case DDD => context.string("ddd").toJSValue()
        }
    }
    public static func fromJSValue(context: JSContext, input: JSValue): TA710 {
        
        throw Exception("unsupport type!")
    }
}


public enum TA720 {
    | NUMBER(Float64)
    | STRING(String)
    
    public func toJSValue(context: JSContext): JSValue {
        match(this) {
            case NUMBER(x) => context.number(x).toJSValue()
            case STRING(x) => context.string(x).toJSValue()
        }
    }
    public static func fromJSValue(context: JSContext, input: JSValue): TA720 {
        
        if(input.isNumber()) {
            return NUMBER(Float64.fromJSValue(context, input))
        }  
        if(input.isString()) {
            return STRING(String.fromJSValue(context, input))
        }
        throw Exception("unsupport type!")
    }
}


public enum TA730 {
    | PROMISE_STRING_(JSValue/* FIXME: `Promise<string>` */)
    | STRING(String)
    
    public func toJSValue(context: JSContext): JSValue {
        match(this) {
            case PROMISE_STRING_(x) => x
            case STRING(x) => context.string(x).toJSValue()
        }
    }
    public static func fromJSValue(context: JSContext, input: JSValue): TA730 {
        
        if(input.isString()) {
            return STRING(String.fromJSValue(context, input))
        }
        throw Exception("unsupport type!")
    }
}


public enum TA740 {
    | AAA
    | TA740TA710(TA710)
    
    public func toJSValue(context: JSContext): JSValue {
        match(this) {
            case AAA => context.string("aaa").toJSValue()
            case TA740TA710(x) => x.toJSValue(context)
        }
    }
    public static func fromJSValue(context: JSContext, input: JSValue): TA740 {
        
        throw Exception("unsupport type!")
    }
}


public type TA810 = JSValue/* FIXME: `{ x: number; y: string }` */


public type TA820 = JSValue/* FIXME: `{ [number]: string }` */


public type TA830 = JSValue/* FIXME: `{ (arg: number) => string }` */


public type TA900 = JSValue/* FIXME: `UnsupportedType[TypeOperator]` */


public type TA910 = JSValue/* FIXME: `UnsupportedType[TypeOperator]` */


public type TA1000 = JSValue/* FIXME: `UnsupportedType[TypeQuery]` */


public type TA1010 = JSValue/* FIXME: `ReturnType` */


public enum ARK1 {
    | NULL
    | NUMBER(Float64)
    | STRING(String)
    | BOOLEAN(Bool)
    | BYTEARRAY(Array<UInt8>)
    | FLOAT32ARRAY(Array<Float32>)
    | BIGINT(BigInt)
    | INT8ARRAY(Array<Int8>)
    | INT16ARRAY(Array<Int16>)
    | UINT16ARRAY(Array<UInt16>)
    | UINT32ARRAY(Array<UInt32>)
    | INT32ARRAY(Array<Int32>)
    | INT64ARRAY(Array<Int64>)
    | UINT64ARRAY(Array<UInt64>)
    | FLOAT64ARRAY(Array<Float64>)
    
    public func toJSValue(context: JSContext): JSValue {
        match(this) {
            case NULL => context.null().toJSValue()
            case NUMBER(x) => context.number(x).toJSValue()
            case STRING(x) => context.string(x).toJSValue()
            case BOOLEAN(x) => context.boolean(x).toJSValue()
            case BYTEARRAY(x) => context.global["Uint8Array"].asClass().new(x.toJSValue(context))
            case FLOAT32ARRAY(x) => context.global["Float32Array"].asClass().new(context.arrayBuffer(x).toJSValue())
            case BIGINT(x) => context.bigint(x).toJSValue()
            case INT8ARRAY(x) => context.global["Int8Array"].asClass().new(context.arrayBuffer(x).toJSValue())
            case INT16ARRAY(x) => context.global["Int16Array"].asClass().new(context.arrayBuffer(x).toJSValue())
            case UINT16ARRAY(x) => context.global["Uint16Array"].asClass().new(context.arrayBuffer(x).toJSValue())
            case UINT32ARRAY(x) => context.global["Uint32Array"].asClass().new(context.arrayBuffer(x).toJSValue())
            case INT32ARRAY(x) => context.global["Int32Array"].asClass().new(context.arrayBuffer(x).toJSValue())
            case INT64ARRAY(x) => context.global["BigInt64Array"].asClass().new(context.arrayBuffer(x).toJSValue())
            case UINT64ARRAY(x) => context.global["BigUint64Array"].asClass().new(context.arrayBuffer(x).toJSValue())
            case FLOAT64ARRAY(x) => context.global["Float64Array"].asClass().new(context.arrayBuffer(x).toJSValue())
        }
    }
    public static func fromJSValue(context: JSContext, input: JSValue): ARK1 {
        
        if (input.isNull()) {
            return NULL
        } 
        if(input.isNumber()) {
            return NUMBER(Float64.fromJSValue(context, input))
        }  
        if(input.isString()) {
            return STRING(String.fromJSValue(context, input))
        } 
        if (input.isBoolean()) {
            return BOOLEAN(Bool.fromJSValue(context, input))
        } 
        if (instanceof(input, "Uint8Array")) {
            let jsArray: JSValue = context.global["Uint8Array"].asObject().callMethod("from", [input])
            return BYTEARRAY(fromJSArray<UInt8>(context, jsArray))
        } 
        if (instanceof(input, "Float32Array")) {
            let jsArray: JSValue = context.global["Float32Array"].asObject().callMethod("from", [input])
            return FLOAT32ARRAY(fromJSArray<Float32>(context, jsArray))
        } 
        if (input.isBigInt()) {
            return BIGINT(input.toBigInt())
        } 
        if (instanceof(input, "Int8Array")) {
            let jsArray: JSValue = context.global["Int8Array"].asObject().callMethod("from", [input])
            return INT8ARRAY(fromJSArray<Int8>(context, jsArray))
        } 
        if (instanceof(input, "Int16Array")) {
            let jsArray: JSValue = context.global["Int16Array"].asObject().callMethod("from", [input])
            return INT16ARRAY(fromJSArray<Int16>(context, jsArray))
        } 
        if (instanceof(input, "Uint16Array")) {
            let jsArray: JSValue = context.global["Uint16Array"].asObject().callMethod("from", [input])
            return UINT16ARRAY(fromJSArray<UInt16>(context, jsArray))
        } 
        if (instanceof(input, "Uint32Array")) {
            let jsArray: JSValue = context.global["Uint32Array"].asObject().callMethod("from", [input])
            return UINT32ARRAY(fromJSArray<UInt32>(context, jsArray))
        } 
        if (instanceof(input, "Int32Array")) {
            let jsArray: JSValue = context.global["Int32Array"].asObject().callMethod("from", [input])
            return INT32ARRAY(fromJSArray<Int32>(context, jsArray))
        } 
        if (instanceof(input, "BigInt64Array")) {
            let jsArray: JSValue = context.global["BigInt64Array"].asObject().callMethod("from", [input])
            return INT64ARRAY(fromJSArray<Int64>(context, jsArray))
        } 
        if (instanceof(input, "BigUint64Array")) {
            let jsArray: JSValue = context.global["BigUint64Array"].asObject().callMethod("from", [input])
            return UINT64ARRAY(fromJSArray<UInt64>(context, jsArray))
        } 
        if (instanceof(input, "Float64Array")) {
            let jsArray: JSValue = context.global["Float64Array"].asObject().callMethod("from", [input])
            return FLOAT64ARRAY(fromJSArray<Float64>(context, jsArray))
        }
        throw Exception("unsupport type!")
    }
}

// 交叉类型别名
public type User = JSValue/* FIXME: `{ id: number; name: string } & { isActive: boolean }` */

// 泛型类型别名
public type ApiResponse = JSValue/* FIXME: `{ data: T; status: number }` */


public type AnimationItem = JSValue/* FIXME: `{ name: string; name1: string }` */


